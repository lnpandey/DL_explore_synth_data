# -*- coding: utf-8 -*-
"""K_5_D_2_elemental.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zoQLSj8dR9l2hXE0VskwiIhHB5oWppZz
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
from matplotlib import pyplot as plt
from tqdm import tqdm
# %matplotlib inline
from torch.utils.data import Dataset, DataLoader
import torch
import torchvision
from sklearn.preprocessing import StandardScaler
from sklearn.svm import SVC
from sklearn.datasets import make_moons

import torch.nn as nn
import torch.nn.functional as F

from plots import plot_analysis,focus_map,classification_map
from Models_Elemental import Focus_linear,Classification_linear
from Models_Elemental import Focus_deep,Classification_deep
from train_mosaic_new import train_mosaic_network
from train_model import train_network


device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
print(device)

n_classes = 5
n_data = n_classes*100
n_mosaic = 3000
K = 5
d = 2

y = np.random.randint(0,n_classes,n_data)
idx= []
for i in range(n_classes):
    print(i,sum(y==i))
    idx.append(y==i)

x = np.zeros((n_data,d))

x[idx[0],:] = np.random.multivariate_normal(mean = [0,0],cov=[[5,0],[0,5]],size=sum(idx[0]))



x[idx[1],:] = np.random.multivariate_normal(mean = [6,0],cov=[[5,0],[0,5]],size=sum(idx[1]))

x[idx[2],:] = np.random.multivariate_normal(mean = [12,0],cov=[[5,0],[0,5]],size=sum(idx[2]))

x[idx[3],:] = np.random.multivariate_normal(mean = [6,6],cov=[[5,0],[0,5]],size=sum(idx[3]))

x[idx[4],:] = np.random.multivariate_normal(mean = [0,-8],cov=[[5,0],[0,5]],size=sum(idx[4]))




std = StandardScaler()
std.fit(x)
x = std.transform(x)
x.shape

for i in range(n_classes):
    plt.scatter(x[y==i,0],x[y==i,1],label="class_"+str(i))
#plt.legend(loc='center left', bbox_to_anchor=(1, 0.5))

foreground_classes = {'class_0' ,'class_1'}

background_classes = {'class_2','class_3'}#,'class_4', 'class_5', 'class_6','class_7', 'class_8', 'class_9'}

mosaic_list =[]
mosaic_label = []
fore_idx=[]
for j in range(n_mosaic):
    fg_class  = np.random.randint(0,len(foreground_classes))
    fg_idx = np.random.randint(0,K)
    a = []
    for i in range(K):
        if i == fg_idx:
            b = np.random.choice(np.where(idx[fg_class]==True)[0],size=1)
            a.append(x[b])
#             print("foreground "+str(fg_class)+" present at " + str(fg_idx))
        else:
            bg_class = np.random.randint(len(foreground_classes),n_classes)
            b = np.random.choice(np.where(idx[bg_class]==True)[0],size=1)
            a.append(x[b])
#             print("background "+str(bg_class)+" present at " + str(i))
    a = np.concatenate(a,axis=0)
    mosaic_list.append(np.reshape(a,(d*K,1)))
    mosaic_label.append(fg_class)
    fore_idx.append(fg_idx)

mosaic_list = np.concatenate(mosaic_list,axis=1).T
mosaic_list.shape

sv = SVC(C=1000,kernel="linear")
sv.fit(mosaic_list,mosaic_label)
print(sv.score(mosaic_list,mosaic_label))

class MosaicDataset(Dataset):
  """MosaicDataset dataset."""

  def __init__(self, mosaic_list, mosaic_label, fore_idx):
    """
      Args:
        csv_file (string): Path to the csv file with annotations.
        root_dir (string): Directory with all the images.
        transform (callable, optional): Optional transform to be applied
            on a sample.
    """
    self.mosaic = mosaic_list
    self.label = mosaic_label
    self.fore_idx = fore_idx

  def __len__(self):
    return len(self.label)

  def __getitem__(self, idx):
    return self.mosaic[idx] , self.label[idx], self.fore_idx[idx]

batch = 250
msd = MosaicDataset(mosaic_list, mosaic_label , fore_idx)
train_loader = DataLoader( msd,batch_size= batch ,shuffle=True)

where = Focus_linear(2,1,K).double()
what = Classification_linear(2,2).double()

train_mosaic = train_mosaic_network(where,what,train_loader,elemental=True,x=x,y=y)

train_mosaic.training(epochs=200,mini=3)

plot_analysis(np.array(train_mosaic.train_analysis))

plt.plot(train_mosaic.train_loss)

_,_,_,_ = train_mosaic.predict(train_loader,True)

where_deep = Focus_deep(2,1,K).double()
what_deep = Classification_deep(2,2).double()

train_mosaic_deep = train_mosaic_network(where_deep,what_deep,train_loader,elemental=True,x=x,y=y)

train_mosaic_deep.training(epochs=200,mini=3)

plot_analysis(np.array(train_mosaic_deep.train_analysis))

plt.plot(train_mosaic_deep.train_loss)

_,_,_,_ = train_mosaic_deep.predict(train_loader,True)

class Net(nn.Module):
  def __init__(self):
    super(Net,self).__init__()
    self.linear1 = nn.Linear(10,50)
    self.linear2 = nn.Linear(50,50)
    self.linear3 = nn.Linear(50,50)
    self.linear4 = nn.Linear(50,2)
  def forward(self,x):
    x = F.relu(self.linear1(x))
    x = F.relu(self.linear2(x))
    x = F.relu(self.linear3(x))
    x = F.relu(self.linear4(x))
    return x

class MosaicDataset(Dataset):
  """MosaicDataset dataset."""

  def __init__(self, mosaic_list, mosaic_label):
    """
      Args:
        csv_file (string): Path to the csv file with annotations.
        root_dir (string): Directory with all the images.
        transform (callable, optional): Optional transform to be applied
            on a sample.
    """
    self.mosaic = mosaic_list
    self.label = mosaic_label
    

  def __len__(self):
    return len(self.label)

  def __getitem__(self, idx):
    return self.mosaic[idx] , self.label[idx]

batch = 250
dataset = MosaicDataset(mosaic_list, mosaic_label )
traindataloader = DataLoader( dataset,batch_size= batch ,shuffle=True)

net = Net().double()
net =net.to(device)
train_model =train_network(net,traindataloader)

train_model.training(epochs=800,mini=3)

train_model.predict(traindataloader,True)

plt.plot(train_model.train_loss)

